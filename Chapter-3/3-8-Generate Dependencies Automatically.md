# 自动生成依赖性

在 Makefile 中，依赖关系可能会包含一些列的头文件，比如 "main.c" 中包含了头文件 "defs.h", 那么依赖关系应该是

`main.o main.c defs.h`

## 自动寻找头文件编译参数

如果是一个大型项目，可能会在开发维护阶段频繁的加入或删除头文件，与之就得修改 Makefile 文件。
为了避免这种繁重并且容易出错的事情，C/C++ 编译提供了一个 -M 的选项，可以自动找源文件中包含的头文件，并生成一个依赖关系。
比如
`cc -M main.c`

其输出是
`main.o : main.c defs.c`

于是编译器就自动生成了依赖关系，也就无需再手动书写若干文件的依赖关系，而是由编译器自动完成。
如果是 GNU的 C/C++ 编译器，得使用 -MM 参数，否则 -M 也将一些标准库的头文件也包含进来。

## Makefile 使用 -M

GNU 组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个 name.c 的文件都生成一个 name.d 的 Makefile文件， .d 文件中存放一个 .c 文件的依赖关系

这样就可以写出 .c 文件和 .d 文件的依赖关系，并让 make 自动更新或者生成 .d 文件，并把其包含再主 Makefile 文件中，这样就可以自动化地生成每个文件的依赖关系了。

下面给出一个模式规则来产生 .d 文件
```
%.d : %.c
    @set -e; rm -f $@;  \
    $(CC) -M $(CPPFLAGS) $< > $@.$$$$; \
    sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@$$$$ > $@;  \
    rm -f $@.$$$$
```

上述代码意思是：
1. 所有的 .d 文件都依赖 .c 文件，rm -f $@ 的意思是删除所有的目标，也就是 .d 文件
2. 为每个依赖文件 $<，也就是 .c 文件生成依赖文件。
   1. $@ 表示模式 %.d 文件
   2. 如果有一个 C 文件名叫 name.c, 那么 % 就是 name，
   3. $$$$ 是一个随即编号，第二行生成的文件有可能是 "name.d.12345"
3. 第三行使用 sed 命令做了一个替换
4. 第 4 行是删除临时文件
 
总而言之，这个模式要做的事，就是在编译器生成的依赖关系中加入 .d 文件的依赖，即把依赖关系
`main.o : main.c defs.h`
转成
`main.o main.d : main.c defs.h`

.d 文件自动更新，并且自动生成了。这个文件加入的不仅是依赖关系，而且包括生成的命令也一并加入，让每个 .d 文件都包含了一个完整的规则。

一旦完成了依赖文件的自动更新任务，接下来就可以把这些自动生成的规则放进我们的主 Makefile 中。
使用 include 命令，引入别的 Makefile 文件
```
sources = foo.c bar.c
include $(sources:.c=.d)
```

上述中的 $(sources:.c=.d) 中的 .c=.d 的意思是做一个替换，将变量 $(sources) 所有字串都替换成 .d

include 会有次序的问题，include 是按次序来载入文件，最先载入的 .d 文件中的目标会成为默认目标。