# 隐含规则的搜索算法

比如我们有一个目标叫 T。下面是搜索目标 T 的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在 Makefile 被载入内存时，会被转换成模式规则。如果标是archive(member) 的函数库文件模式，那么这个算法会被运行两次，第一次是找目标 T，如果没有找到的话，那么进入第二次，第二次会把 member 当作 T 来搜索。

1. 把 T 的目录部分分离出来。叫 D，而剩余部分叫 N。（如：如果 T 是 src/foo.o ，那，D 就是src/ ，N 就是 foo.o ）
2. 创建所有匹配于 T 或是 N 的模式规则列表。
3. 如果在模式规则列表中有匹配所有文件的模式，如 % ，那么从列表中移除其它的模式。
4. 移除列表中没有命令的规则。
5. 对于第一个在列表中的模式规则：
   1. 推导其“茎”S，S 应该是 T 或是 N 匹配于模式中 % 非空的部分。
   2. 计算依赖文件。把依赖文件中的 % 都替换成“茎”S。如果目标模式中没有包含斜框字符，而把 D 加在第一个依赖文件的开头。
   3. 测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫“理当存在”）
   4. 如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。
6.  如果经过第 5 步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：
    1. 如果规则是终止规则，那就忽略它，继续下一条模式规则。
    2. 计算依赖文件。（同第 5 步）
    3. 测试所有的依赖文件是否存在或是理当存在。
    4. 对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。
    5.  如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。
    6. 如果没有隐含规则可以使用，查看 .DEFAULT 规则，如果有，采用，把 .DEFAULT 的命令给 T 使用。

一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。