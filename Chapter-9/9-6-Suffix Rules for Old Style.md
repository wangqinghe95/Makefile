# 老式风格的 “后缀规则”

后缀规则是比较老的版本定义隐含规则的方法。此后后缀规则逐渐被模式规则逐步的取代。因为模式规则更强且更清晰。

后缀规则有两种方法，“双后缀”和“单后缀”

1. 双后缀是定义一对后缀，目标文件的后缀和依赖目标（源文件）的后缀。如 .c.o 相当于 %.o : $.c
2. 单后缀只定义一个后缀，也就是源文件的后缀，如 `% : %.c`

后缀规则中所定义的后缀需要是在 make 中所支持的，如果一个后缀已经被 make 认识，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被 make 所认识，那么就是双后缀规则。

比如 .o 和 .c 都被 make 所知道，那么定义了一个规则中包含这两个后缀的规则就是双后缀规则，意义就是 .c 文件是源文件后缀， .o 是目标文件的后缀。如下
```
.c.o:
    $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<
```

后缀规则不允许任何的依赖文件，如果有依赖文件就不是后缀规则了，这些后缀统统被认为是文件名
```
.c.o : foo.h
    $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<
```
意思是说，文件 .c.o 依赖于文件 foo.h

如果我们想要设置规则说所有 .o 文件都是由 .c 文件生成，且依赖 foo.h，则如下
```
%.o: %.c foo.h
    $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<
```

make 不会为后缀规则执行隐含规则命令，所以后缀规则必须需要写明命令。

可以在 make 中设置一些特定的后缀，使用伪目标 .SUFFIXES 来定义或者删除，如
`.SUFFIXESL .hack .win`

把后缀 .hack 和 .win 假如后缀列表中的末尾
```
.SUFFIXES:
.SUFFIXES: .c .o .h
```

先清除默认后缀，后定义自己的后缀列表

make 参数 -r 或者 -no-builtin-rules 也可以清空后缀列表。变量 USFFIEXE 定义默认的后缀列表。
可以使用 .SUFFIXES 改变后缀列表，但是不要轻易修改 SUFFIXE 的值
