# 定义模式规则

1. 使用模式规则可以定义一个隐含规则。一个模式规则类同于一个一般规则，在这个规则里目标的定义都需要有 % 字符。
   1. 该字符表示一个或任意多个字符，在依赖目标中同样可以使用 %，只是依赖目标中的 % 的取值，取决于其目标。
2. % 的展开发生在变量和函数展开之后，变量和函数的展开发生在 make 载入 Makefile 时，而模式规则中的 % 则发生在运行时

## 模式规则介绍

1. 定义一个模式规则，需要在规则的目标定义中包含一个 %。表示对文件名的匹配，匹配长度任意的非空字符串。
   1. %.c 表示以 .c 结尾的文件名。s.%.c 表示以  .s 开头，.c 结尾的文件名
2. 如果在目标中包含了 % ,那么依赖中的 % 的值决定了目标中的 % 的值，也就是说，依赖中的模式 % 决定了目标中 % 的样子。例：

```
%.o : %.c ;<command ......>;
```

其含义是：指出了如何从所有的 .c 文件生成相应的 .o 文件。如果要生成的目标是 a.o b.o, 那么 %c 就是 a.c b.c

## 模式规则示例

1. 把所有的 .c 文件都编译成 .o 文件
```
%.o : %.c
    $(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@
```

$@ 表示所有的目标的挨个值，$< 表示所有依赖目标的挨个值，都是自动化变量

2. 两个目标是模式的

```
%.tab.c %.tab.h : %.y
    bison -d $<
```

这条规则的意思是：所有的 .y 文件都以 bison -d <n>.y 执行，然后生成 <n>.tab.c 和 <n>.tab.h 文件。
假如，我们有一个执行文件 foo 依赖文件 parse.tab.o 和 scan.o
scan.o 文件依赖 parse.tab.h
如果此时，parse.y 文件更新，那么根据上述规则，`bison -d parse.y` 就会被执行一次
此时 parse.tab.o 和 scan.o 依赖文件就齐了。

## 自动化变量

在模式规则中，目标和依赖文件都是一系列文件，那么如何能够使用一条命令就能完成不同的依赖文件生成相应的目标？这就是自动化变量的作用。

下面介绍 Make 中各个自动化变量和说明

| 自动化变量 | 说明 |
| $@ | 表示规则中的目标文件集。在规则中，如果有多个目标，那么 $@ 就是匹配于目标中牧模式定义的集合 |
| $% | 仅当目标是函数库文件中，表示规则中的目标成员名。 |
| $< | 依赖目标的第一个目标名称。如果依赖目标是以模式定义的，那么 $< 将是符合模式的一系列文件集，注意是逐一取出来的 |
| $? | 所有比目标新的依赖目标的集合。以空格隔开 |
| $^ | 所有依赖目标的集合，以空格分隔，如果依赖目标中有多个重复的，将会被去重 |
| $+ | 类似 $^ , 所有依赖目标的集合，但是不去重 |
| $* | 这个变量表示目标模式中 % 及其之前的部分 |

+ `$%`: 如果一个目标是  foo.a（bar.o），那么 `$%` 是 bar.o，$@ 是 foo.a。如果目标不是函数库文件（Unix 下是 .a，Windows 下是 lib），那么其值是空。
+ `$*`：如果目标是 dir/a.foo.b，并且目标的模式是 a.%.b，那么 $* 的值就是 dir/foo。这个变量对于构造有关联的文件名比较有效果。
  + 如果目标中没有模式的定义，那么 $* 也不会被推导出来，但是如果目标文件的后缀是 make 所识别的，那么 $* 就是除了后缀的那一部分。
  + 例如， foo.c ，因为 .c 是 make 所能识别的后缀名，所以 $* 的值就是 foo。
  + 因为谨慎使用 $*，因为这个特性仅支持 GNU make

例：
假如，有一个函数库文件叫 lib，依赖其他 objects 文件，那么它们对应的生成关系应该如下：
```
lib : foo.o bar.o lose.o win.o
    ar r lib $?
```

在上述的自动变量中，四个变量($@,$<,$%,$*) 在扩展时只会有一个文件，而另三个值是一个文件列表。
这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名。
使用函数 dir 或者 notdir ，或者是加上 D 或者 F 字样。
以下是对于上面七个变量分别加上 D 或者 F 的含义。
1. $(@D)
   1. 表示 $@ 的目标部分（不以斜杠结尾）
   2. 如果 $@ 的值是 dir/foo.o，那么 $(@D) 就是 dir
   3. 而如果 $@ 没有包含斜杠的话，那么其值就是 . 表示当前目录
2. $(@F)
   1. 表示 $@ 的文件部分
   2. 如果 $@ 的值是 dir/foo.o，那么 $(@F) 就是 foo.o
   3. $(@F)相当于函数 $(notdir $@)
3. $(*D),$(*F)
   1. 取文件的目录部分和文件部分。
   2. 对于上面的那个例子，$(*D) 返回 dir ，而 $(*F) 返回 foo
4. $(%D),$(%F)
   1. 分别表示了函数包文件成员的目录部分和文件部分
   2. 这对于形同 archive(member) 形式的目标中的 member 中包含了不同的目录很有用。
5. $(<D), $(<F)
   1. 分别表示依赖文件的目录部分和文件部分。
6. $(^D), $(^F)
   1. 分别表示所有依赖文件的目录部分和文件部分。（无相同的）
7. $(+D), $(+F)
   1. 分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）
8. $(?D), $(?F)
   1. 分别表示被更新的依赖文件的目录部分和文件部分。

最后想提醒一下的是，对于 $< ，为了避免产生不必要的麻烦，我们最好给 $ 后面的那个特定字符都加上圆括号，比如，$(<) 就要比 $< 要好一些。

## 模式的匹配

## 重载内建隐含规则

可以重新构造和内建隐含规则不同的命令，如：
```
%.o : %.c
    $(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(date)
```

你可以取消内建的隐含规则，只要不在后面写命令就行。如：
`%.o : %.s`

同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。
