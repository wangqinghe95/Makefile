# 隐含规则使用

## 定义
隐含规则是一种未指明的，在 Make 中早先约定好了的，不需要我们在写出来的规则。
可能会使用一些系统变量，改变这些系统变量的值来定制隐含规则运行时的参数。如系统变量 CFLAGS 可以控制编译时的编译器参数
可以定制隐含规则。

## 使用
如果想要使用隐含规则生成所需要的目标，需要做的就是不要显示写出这个目标的规则。
make 会试图自动去推动这个目标的规则和命令。如果可以，那么这个行为就是隐含规则的自动推导。

如
```
foo : foo.o bar.o
    cc -o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)
```

上面的例子中是没有写如何生成 foo.o 和 bar.o 这两个目标的规则和命令。
因为 make 的“隐含规则” 功能会去自动推导这两个目标的依赖目标和生成命令。

## 隐含规则原理

make 会在自己的 “隐含规则” 库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，就报错。
上面的例子中，make 调用的 “隐含规则” 是，把 .o 的目标的依赖文件置为 .c, 并使用 C 的编译命令 `cc -c $(CFLAGS) foo.c` 来生成 foo.o 的目标

如果我们手动输入了以下的规则和命令
```
foo.o : foo.c
    cc –c foo.c $(CFLAGS)
bar.o : bar.c
    cc –c bar.c $(CFLAGS)
```

make 就不会去推导并调用隐含规则，直接按照显示的规则和命令执行。

## 其他
make 的 “隐含规则库” 中，每一条隐含规则都是有顺序的，越靠前的是越被经常使用的。所以这会导致我们有时候即使显示地指定了目标依赖，make 也不会管。
如下
`foo.o : foo.p`

依赖文件可能无效，如果在目录下存在 foo.c 文件，那么隐含规则一样生效，通过 foo.c 文件生成 foo.o 文件。

如果确实希望任何隐含规则推导都不生效，那么就把依赖规则和命令都写出来。