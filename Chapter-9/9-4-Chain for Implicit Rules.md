# 隐含规则链

## 隐含规则链
如果一个目标被一系列的隐含规则所作用，比如一个 .o 文件的生成，可能会先被 Yacc 的 [.y] 文件先生成 .c ，然后再被 C 的编译器生成。这样的一系列隐含规则被称为 “隐含规则链”

如果文件的 .c 存在，那么直接调用 C 编译器的隐含规则，如果没有 .c 文件，但是有一个 .y 文件，那么 Yacc 的隐含规则会被调用，生成 .c 文件，再调用 C 编译的隐含规则最终由 .c 生成 .o 文件，达到目标。


## 中间目标
上述例子种的 .c 就是一个目标文件。make 会努力自动推导生成目标。不管中间目标有多少，都会将其中所有的隐含规则和书写的规则结合起来分析。

在默认情况下，对于中间目标，它和一般的目标有两个地方不同，第一个不同是除非中间目标不存在，才会触发中间规则；第二是只要目标成功产生，那么产生目标过程中所产生的中间目标文件都会被 rm -f 删除。

一个被 makefile 指定成目标或是依赖目标的文件不能被当作中介。但是可以通过显示地指定一个文件或者目标是中间目标，方法就是使用伪目标 .INTERMEDIATE 来强制声明，

也可以阻止 make 自动删除中间目标，要做到这一点，可以使用 .SECONDARY 来强制声明（如 .SECONDARY : sec），还可以把目标以模式地方式来指定 (%.o) 成伪目标 .PRECIOUS 的依赖目标，以保持被隐式规则所生成的中间文件。

在 “隐式规则链” 中，禁止同一个目标出现两次或者两次以上，这样就可以防止 make 自动推导时无限递归的情况

make 会优化一些特殊的隐式规则，而不生成中间文件。如从文件 foo.c 生成目标程序 foo，按一般流程，make 会编译成中间文件 foo.o，再链接成 foo, 在实际情况下，这一动作会被 cc 的命令 `cc -o foo foo.c`，于是优化过的规则不会产生中间文件。